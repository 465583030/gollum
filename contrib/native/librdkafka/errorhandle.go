// Copyright 2015-2016 trivago GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package librdkafka

// #cgo CFLAGS: -I/usr/local/include
// #cgo LDFLAGS: -L/usr/local/opt/librdkafka/lib -L/usr/local/lib -lrdkafka
// #include "wrapper.h"
// #include <string.h>
import "C"

import (
	"reflect"
	"unsafe"
)

//export goMarshalAsyncError
func goMarshalAsyncError(code C.int, reason *C.char, hook *C.ErrorHook_t) {
	topic := allTopics[int(hook.topic)]
	topic.pushError(int(code), int(hook.index))
}

func makeErrorHook(topic *Topic, index int) unsafe.Pointer {
	return unsafe.Pointer(C.NewErrorHook(C.int(topic.id), C.int(index)))
}

// ErrorHandle is a convenience wrapper for handling librdkafka native errors.
// This struct fulfills the standard golang error interface.
type ErrorHandle struct {
	errBuffer [512]byte
}

func (l *ErrorHandle) buffer() *C.char {
	return (*C.char)(unsafe.Pointer(&l.errBuffer[0]))
}

func (l *ErrorHandle) len() C.size_t {
	return C.size_t(len(l.errBuffer))
}

func (l *ErrorHandle) Error() string {
	for i := 0; i < len(l.errBuffer); i++ {
		if l.errBuffer[i] == 0 {
			return string(l.errBuffer[:i])
		}
	}

	return string(l.errBuffer[:len(l.errBuffer)])
}

// ResponseError is used as a wrapper for errors generated by the batch
// producer. The Code member wraps directly to the librdkafka error
// number. The original message is attached to allow backtracking.
type ResponseError struct {
	Original Message
	Code     int
}

func (r ResponseError) Error() string {
	nativeString := C.rd_kafka_err2str(C.rd_kafka_resp_err_t(r.Code))
	if nativeString == nil {
		return "Unknown error"
	}

	textHeader := reflect.StringHeader{
		Data: uintptr(unsafe.Pointer(nativeString)),
		Len:  int(C.strlen(nativeString)),
	}
	text := (*string)(unsafe.Pointer(&textHeader))
	return *text
}
