// Copyright 2015 trivago GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package shared

import (
	"sync"
	"time"
)

// ConsumerControl is an enumeration used by the Producer.control() channel
type ConsumerControl int

const (
	// ConsumerControlStop will cause the consumer to halt and shutdown.
	ConsumerControlStop = ConsumerControl(1)

	// ConsumerControlRoll notifies the consumer about a reconnect or reopen request
	ConsumerControlRoll = ConsumerControl(2)

	metricActiveConsumers = "ActiveConsumers"
)

// Consumer is an interface for plugins that recieve data from outside sources
// and generate Message objects from this data.
type Consumer interface {
	// Consume should implement to main loop that fetches messages from a given
	// source and pushes it to the Message channel.
	Consume(*sync.WaitGroup)

	// IsActive returns true if the consumer is ready to generate messages.
	IsActive() bool

	// Control returns write access to this consumer's control channel.
	// See ConsumerControl* constants.
	Control() chan<- ConsumerControl

	// Messages returns a read only access to the messages generated by the
	// consumer.
	Messages() <-chan Message
}

// ConsumerBase base class
// All consumers support a common subset of configuration options:
//
// - "consumer.Something":
//   Enable: true
//   Channel: 1024
//   Stream:
//      - "error"
//      - "default"
//
// Enable switches the consumer on or off. By default this value is set to true.
//
// Channel sets the size of the channel used to communicate messages. By default
// this value is set to 1024
//
// Stream contains either a single string or a list of strings defining the
// message channels this consumer will produce. By default this is set to "*"
// which means only producers set to consume "all streams" will get these
// messages.
type ConsumerBase struct {
	messages chan Message
	control  chan ConsumerControl
	streams  []MessageStreamID
	state    *PluginRunState
	timeout  time.Duration
}

// ConsumerError can be used to return consumer related errors e.g. during a
// call to Configure
type ConsumerError struct {
	message string
}

func init() {
	Metric.New(metricActiveConsumers)
}

// NewConsumerError creates a new ConsumerError
func NewConsumerError(message string) ConsumerError {
	return ConsumerError{message}
}

// Error satisfies the error interface for the ConsumerError struct
func (err ConsumerError) Error() string {
	return err.message
}

// Configure initializes standard consumer values from a plugin config.
func (cons *ConsumerBase) Configure(conf PluginConfig) error {
	cons.messages = make(chan Message, conf.Channel)
	cons.control = make(chan ConsumerControl, 1)
	cons.streams = make([]MessageStreamID, len(conf.Stream))
	cons.timeout = time.Duration(conf.GetInt("ChannelTimeout", 1000)) * time.Millisecond
	cons.state = new(PluginRunState)

	for i, stream := range conf.Stream {
		cons.streams[i] = GetStreamID(stream)
	}

	return nil
}

// SetWaitGroup sets the given waitgroup. This is also done by MarkAsActive so
// it is only needed when AddWorker is called before MarkAsActive.
func (cons *ConsumerBase) SetWaitGroup(threads *sync.WaitGroup) {
	cons.state.WaitGroup = threads
}

// MarkAsActive adds this consumer to the wait group and marks it as active
func (cons *ConsumerBase) MarkAsActive(threads *sync.WaitGroup) {
	cons.state.WaitGroup = threads
	cons.state.WaitGroup.Add(1)
	cons.state.Active = true
	Metric.Add(metricActiveConsumers, 1)
}

// MarkAsDone removes the consumer from the wait group and marks it as inactive
func (cons ConsumerBase) MarkAsDone() {
	cons.state.WaitGroup.Done()
	cons.state.Active = false
	Metric.Sub(metricActiveConsumers, 1)
}

// AddWorker adds an additional worker to the waitgroup. Assumes that either
// MarkAsActive or SetWaitGroup has been called beforehand.
func (cons ConsumerBase) AddWorker() {
	cons.state.WaitGroup.Add(1)
}

// WorkerDone removes an additional worker to the waitgroup.
func (cons ConsumerBase) WorkerDone() {
	cons.state.WaitGroup.Done()
}

// IsActive returns true if the consumer is ready to generate messages.
func (cons ConsumerBase) IsActive() bool {
	return cons.state.Active
}

// PostMessage sends a message text to all configured streams.
// This method blocks of the message queue is full.
func (cons ConsumerBase) PostMessage(text string, sequence uint64) {
	PostMessage(cons.messages, NewMessage(text, cons.streams, sequence), cons.timeout)
}

// PostMessageFromSlice sends a buffered message to all configured streams.
// This method blocks of the message queue is full.
func (cons ConsumerBase) PostMessageFromSlice(data []byte, sequence uint64) {
	PostMessage(cons.messages, NewMessageFromSlice(data, cons.streams, sequence), cons.timeout)
}

// Control returns write access to this consumer's control channel.
// See ConsumerControl* constants.
func (cons ConsumerBase) Control() chan<- ConsumerControl {
	return cons.control
}

// Messages returns a read only access to the messages generated by the
// consumer.
func (cons ConsumerBase) Messages() <-chan Message {
	return cons.messages
}

// ProcessCommand provides a callback based possibility to react on the
// different consumer commands. Returns true if ConsumerControlStop was triggered.
func (cons ConsumerBase) ProcessCommand(command ConsumerControl, onRoll func()) bool {
	switch command {
	default:
		// Do nothing
	case ConsumerControlStop:
		return true // ### return ###
	case ConsumerControlRoll:
		if onRoll != nil {
			onRoll()
		}
	}

	return false
}

// DefaultControlLoop provides a consumer mainloop that is sufficient for most
// usecases. It marks this consumer as active and loops over ProcessCommand
// as long as the consumer is marked as active.
func (cons ConsumerBase) DefaultControlLoop(threads *sync.WaitGroup, onRoll func()) {
	cons.MarkAsActive(threads)

	for cons.IsActive() {
		command := <-cons.control
		if cons.ProcessCommand(command, onRoll) {
			return // ### return ###
		}
	}
}

// TickerControlLoop is like DefaultControlLoop but executes a given function at
// every given interval tick, too.
func (cons ConsumerBase) TickerControlLoop(threads *sync.WaitGroup, interval time.Duration, onRoll func(), onTick func()) {
	ticker := time.NewTicker(interval)
	cons.MarkAsActive(threads)

	for cons.IsActive() {
		select {
		case command := <-cons.control:
			if cons.ProcessCommand(command, onRoll) {
				return // ### return ###
			}
		case <-ticker.C:
			onTick()
		}
	}
}
